
====================
COMANDOS ESSENCIAIS:
====================

1 - git pull origin main -- Sincroniza Repositorio Local com o Remoto(github)


=======
SNIPTS:
=======

/*** ORIGIN CORS ***/

const io = require('socket.io')(server,{cors:{
    origin:'*:*',
    credentials: true
}}


/*** nodejs servidor api***/

const micros = require("./arqsjson/micros.json");
app.get('/arqsjson', (requisicao, resposta) => {
	return resposta.json(micros);
});



/*** esp8266 cliente da api nodejs ***/

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClient.h>

const char* ssid = "Welwitschia Mirabilis";
const char* password = "tigre?2018@";
/*const char* ssid = "TPLINK";
const char* password = "gregorio@2012";*/
WiFiClientSecure client;
HTTPClient sender;

/////////////
// setup() //
/////////////
void setup(){

  Serial.begin(115200); // serial monitoring
  
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED){
      delay(200);
      Serial.print(".");
  }

  Serial.println(F("\nConnected to WIFI!"));

  const char *host_url = "https://nodejs-h07r.onrender.com/arqsjson";
  uint16_t porta = 443;

  client.setInsecure();
  client.connect(host_url, porta);
  
  if (sender.begin(client, host_url)){
    
    uint16_t httpCode = sender.GET();

    if (httpCode > 0) 
    {
      if (httpCode == HTTP_CODE_OK){
        String payload = sender.getString();        
        Serial.println(payload);
      }
      else{
        Serial.printf("HTTP-Error: %s\n", sender.errorToString(httpCode).c_str());
      }
    }
  }
  else{
    Serial.println(F("Other HTTP error"));
    sender.end();
  }
}


////////////
// loop() //
////////////
void loop(){
  
}







==========
websockets
==========

/*var fs = require('fs');
var url = require('url');
var http = require('http');
var WebSocket = require('ws');

// function gửi yêu cầu(response) từ phía server hoặc nhận yêu cầu (request) của client gửi lên
function requestHandler(request, response) {
    fs.readFile('./public/index.html', function(error, content) {
        response.writeHead(200, {
            'Content-Type': 'text/html'
        });
        response.end(content);
    });
}

// create http server
var server = http.createServer(requestHandler);
var ws = new WebSocket.Server({
    server
});
var clients = [];

function broadcast(socket, data) {
    console.log(clients.length);
    for (var i = 0; i < clients.length; i++) {
        if (clients[i] != socket) {
            clients[i].send(data);
        }
    }
}
ws.on('connection', function(socket, req) {
    clients.push(socket);
    socket.on('message', function(message) {
        console.log('received: %s', message);
        broadcast(socket, message);
    });
    socket.on('close', function() {
        var index = clients.indexOf(socket);
        clients.splice(index, 1);
        console.log('disconnected');
    });
});

server.listen(3000);

console.log('Server listening on port 3000');*/







/*
const path = require('path');
//import express from 'express';
const express = require('express');
//import http from 'http';
const http = require('http');
//import { Server } from 'socket.io';
const Server = require('socket.io');

const PORT = process.env.PORT || 3000;

const app = express();
const httpServer = http.createServer(app);
//const io = new Server(httpServer, { cors: { origin: '*' } });
const io = Server(httpServer);

//app.use(express.static('src/ui'));
app.use(express.static(path.join(__dirname, 'public')));

let buttonState = false;

io.on('connection', socket => {
    console.log('New Connection');

    io.to(socket.id).emit('buttonState', buttonState);

    socket.on('disconnect', () => {
        console.log('Disconnected');
    });

    socket.on('buttonState', value => {
        console.log('buttonState:', value);
        buttonState = value;
        socket.broadcast.emit('buttonState', value);
    });
});

httpServer.listen(PORT, () => {
    console.log('Running on : ', httpServer.address());
});
*/